
# Continue `specifyr_info_prototype.R`, starting with a new slate.

# Test Compression -------------------------------------------------------------

# IDEA: For the test, what if we store a modified "AST", where the only calls are
# those to `&&`, `&`, or `||`.

# This generates the following AST
lobstr::ast(p1 && p2 && (f(p3) == g(p4)))
# █─`&&`
# ├─█─`&&`
# │ ├─p1
# │ └─p2
# └─█─`(`
#   └─█─`==`
#   ├─█─f
#   │ └─p3
#   └─█─g
#     └─p4

# But in our context, we don't actually case about calls to `f`, `==`, `g`. We
# consider this entire expression `f(p3) == g(p4)` to be a symbol.
#
# Supposing `p34` is `f(p3) == g(p4)`, we have the modified AST:
lobstr::ast(p1 && p2 && p34)

# This is our fake "AST", following the same rules of the normal AST tree, but
# caring only about the `&&`, `&`, or `||` generated by `and()` or `or()`.
list(
  `&&` = list(
    `&&` = list(
      quote(p1),
      quote(p2)
    ),
    quote(f(p3) == g(p4))
  )
) |> str()

# Formalize the fake ast, expressions connected by logical and / or
new_test_ast <- function(call, args) {
  stopifnot(rlang::is_string(call) && call %in% c("&&", "&", "||", "|"))
  stopifnot(
    is.list(args),
    purrr::map_lgl(args, \(arg) rlang::is_expression(arg) || is_test_ast(arg))
  )
  structure(args, call = call, class = "test_ast")
}

is_test_ast <- function(x) inherits(x, "test_ast")
test_ast_call <- function(x) attr(x, "call")
test_ast_args <- function(x) unclass(x)

ast <- new_test_ast(
  call = "&&",
  args = list(
    new_test_ast(call = "&&", args = list(quote(p1), quote(p2))),
    quote(f(p3) == g(p4))
  )
)

# Assign each node of the tree (e.g. `p1`, `p2`, ...) to a symbol `t*`.
t_index <- 0
ast <- purrr::modify_tree(
  x = ast,
  is_node = is.list,
  leaf = \(expr) {
    t_sym <- rlang::sym(paste0("t", t_index))
    t_index <<- t_index + 1
    rlang::expr(!!t_sym <- !!expr)
  }
)

# Convert a <test_ast> object into an expression
test_ast_to_expr <- function(ast) {
  call <- test_ast_call(ast)
  args <- purrr::modify_if(
    .x = test_ast_args(ast),
    .p = is_test_ast,
    .f = test_ast_to_expr
  )
  rlang::call2(.fn = call, !!!args)
}

binary_ast <- function(call, lhs, rhs) {
  stopifnot(
    rlang::is_string(call) && call %in% c("&&", "&", "||", "|"),
    is_binary_ast(lhs) || rlang::is_expression(lhs),
    is_binary_ast(rhs) || rlang::is_expression(rhs)
  )
  structure(list(call = call, lhs = lhs, rhs = rhs), class = "binary_ast")
}

is_binary_ast <- function(x) inherits(x, "binary_ast")

binary_ast_to_expr <- function(ast) {
  lhs <- ast$lhs
  rhs <- ast$rhs
  if (is.list(lhs)) lhs <- binary_ast_to_expr(lhs)
  if (is.list(rhs)) rhs <- binary_ast_to_expr(rhs)
  rlang::call2(.fn = ast$call, lhs, rhs)
}

if (FALSE) {
  ast <- binary_ast(
    call = "&&",
    lhs = binary_ast("&&", quote(p1), quote(p2)),
    rhs = quote(f(p3) == g(p4))
  )

  # Note! This process can actually replace what's happening in `binary_ast_to_expr()`.
  t_index <- 0
  purrr::modify_tree(
    x = ast,
    is_node = is.list,

    # Turn each leaf (test expression) into an assignment
    leaf = \(x) {
      if (!is.character(x)) {
        t_sym <- rlang::sym(paste0("t", t_index))
        t_index <<- t_index + 1
        rlang::expr(!!t_sym <- !!x)
      } else {
        x
      }
    },

    # Then, collapse each node into an expression (reduces the ast to a single expression)
    post = \(ast) rlang::call2(.fn = ast$call, ast$lhs, ast$rhs)
  )
}

# Simple test, and, or ---------------------------------------------------------

# Just grabs a symbol from the caller environment, returns `NULL` symbol doesn't exist
env_get_result <- function(symbol) {
  env <- rlang::caller_env()
  rlang::env_get(
    env = env,
    nm = rlang::as_string(rlang::enexpr(symbol)),
    default = NULL
  )
}

# Method for collecting the `test` expression from different {specifyr} functions
get_test <- function(fn, ...) {
  UseMethod("get_test")
}

get_test.specifyr_test <- function(fn) {
  # <specifyr_info> function bodies look like this:
  # { <test to get> }
  # Index `[[2]]` gets expression `<test to get>` (i.e. first arg to `{`)
  rlang::fn_body(fn)[[2]]
}

get_test.specifyr_info <- function(fn) {
  # <specifyr_info> function bodies look like this:
  # {
  #   force(<test to get>)
  #   <other stuff>
  # }
  # Index `[[2]][[2]]` gets expression `<test to get>`
  # (i.e. first arg of `{`, then of `force`)
  rlang::fn_body(fn)[[2]][[2]]
}

# Method for collecting the bullets expression from different {specifyr} functions
get_bullets <- function(fn, ...) {
  UseMethod("get_bullets")
}

get_bullets.specifyr_info <- function(fn) {
  # <specifyr_info> function bodies look like this:
  # {
  #   force(test)
  #   bullets <- <bullets to get>
  #   <other stuff>
  # }
  # Index `[[3]][[3]]` gets expression `<bullets to get>`
  rlang::fn_body(fn)[[3]][[3]]
}

# Given a test expression of the form `.t1. <- t1 op ... op .tn. <- tn` where
# `t*` is a user supplied `test()` expression, create a named list of `t*`
# expressions with `.t*.` symbols as the names.
test_expr_dict <- function(expr) {
  stopifnot("`test` must be an expression." = rlang::is_expression(expr))

  t_symbol_pattern <- "\\.t[0-9]+\\."
  dict <- list()

  is_t_assignment <- function(call) {
    if (!identical(call[[1]], quote(`<-`))) {
      return(FALSE)
    }
    grepl(x = rlang::as_string(call[[2]]), pattern = t_symbol_pattern)
  }
  get_t_assignments <- function(expr) {
    if (!rlang::is_call(expr)) {
      # By design, a t-assignment will only ever exist within a call
      return()
    } else if (is_t_assignment(expr)) {
      # The LHS (`x`) argument of the `<-` call is the dictionary key. The
      # RHS (`value`) argument is the entire user-supplied expression.
      t_symbol <- expr[[2]]
      dict[[t_symbol]] <<- expr[[3]]
    } else {
      # The recursive case, we check all of the call arguments for t-assignments
      purrr::map(as.list(expr[-1]), get_t_assignments)
    }
  }

  # Add the t-assignments to the dictionary
  get_t_assignments(expr)
  dict
}


